\chapter{\label{chap:ai}Algoritmos de Inteligência Artificial para Elevadores}

Neste capítulo vamos apresentar:

\begin{itemize}
\item Os detalhes dos algoritmos selecionados e justificar a suas escolhas perante o problema;
\item Introduzir o modelo de simulação do sistema~-~ou seja, a modelagem
prédio/andares/elevadores (e não a modelagem do simulador propriamente dito);
\item Detalhes de cada algoritmo e descrever como esperamos que seja o resultado de seu uso junto ao sistema.
\end{itemize}

% TODO: Mais introdução
A literatura fala em alguns algoritmos utilizados para a escolha de qual
elevador atenderá um pedido. Alguns deles são triviais e não devem ser
enquadrados no termo Inteligência Artificial, no entanto, sua implementação é
interessante, no mínimo para fins de comparação com os demais algoritmos.
% TODO: Referências

Conforme os algoritmos vão ficando mais complexos, mais dados são necessários.
Em um mundo perfeito, ter-se-ia todos os dados de cada passageiro~-~\textit{i.e.} cada
pessoa que chegasse ao elevador informaria de antemão para qual andar deseja ir.
No entanto, isto não é realista nos sistemas atuais. Portanto, os algoritmos
aqui descritos tentam fazer inferências a respeito de dados que não possuem,
quando relevante\footnote{\textit{e.g.} Podemos estimar a lotação do elevador
  com base no peso reportado pela balança interna do elevador, que já se
  encontra nele por motivos de segurança.}, ou tentar tomar decisões ignorando
os dados que não estão disponíveis.

\section{\label{sec:ai:nn}Nearest Neighbour}

O algoritmo de \textit{Nearest Neighbour} é o mais ingênuo de todos, e servirá
de base para a avaliação dos demais algoritmos.

Seu funcionamento é trivial: o elevador mais próximo do chamado sempre
atenderá este chamado.

Um dos muitos problemas deste algoritmo é que ele pode causar muitas mudanças de
direção de um elevador, o que acarreta num tempo de espera maior para os
passageiros dele.

O único propósito deste algoritmo é servir de base de comparação com outros
algoritmos propostos, de modo a validarmos o simulador. Espera-se que uma
melhora clara de desempenho seja notado ao comparar-se este com o próximo dos
mais triviais, o \textit{Nearest Neighbour Melhorado}.

% TODO: Quem fala nele?

\section{\label{sec:ai:nnm}Nearest Neighbour Melhorado}

Uma melhoria que pode ser feita ao algoritmo de \textit{Nearest Neighbour}
é considerar o sentido em que o elevador está indo para atender o chamado. Isto
implica em considerar-se agora a informação de sentido dos pedidos. É importante
notar que ainda não se considera quantas pessoas fizeram um pedido para qual
sentido~-~apenas sabe-se que há pedidos no andar, e como destinos tem-se ``para
cima'', ``para baixo'' ou ambos.

Este algoritmo resolve o problema de mudanças de direção que o algoritmo de
\textit{Nearest Neighbour} sofre.

No entanto, sua escolha para este trabalho também se dá para fim de comparação
com os outros e validação do simulador. Como seu comportamento é diferente do
caso mais trivial, mas ainda assim bastante simples, poderá ser visto com clareza
algum tipo de melhora no tempo de resposta do sistema simulado, bem como a validade do simulador.

\section{\label{sec:ai:minimize-cost-function}Minimização da Função de Custo}

O primeiro algoritmo de IA a ser testado é simples: define-se uma
função de custo, inerente a cada elevador, que descreve matematicamente quão
vantajoso é atender um pedido, comparado a não atendê-lo. A decisão de qual
elevador é escolhido para atender o pedido é feita com base única e
 exclusivamente em qual deles terá o menor valor da função de custo.

Um exemplo de função de custo é:

\[
  J(e) = g_{e}f_{e}
\]

Onde:
\begin{itemize}
\item \textbf{$g_{e}$} é a lotação do elevador
\item \textbf{$f_{e}$} é
  \begin{itemize}
    \item zero, caso o programa atual do elevador faça com que ele passe por
      aquele andar
    \item o número de andares entre onde o elevador está e o pedido, caso o
      elevador não tenha um programa (\textit{i.e.}, ele esteja ocioso) ou o
      elevador esteja indo na direção do pedido.
    \item duas vezes o número de andares entre onde o elevador está e o pedido,
      caso ele mude de direção para atender este pedido.\footnote{Multiplica-se
        a distância por dois pois é necessário ir até o andar do pedido e então
        voltar para o andar onde se estava anteriormente, para só então atender
        o pedido.}
  \end{itemize}
\end{itemize}

\begin{figure}[htb!]
  \centering
  \includegraphics[scale=0.6]{img/elevator_example1.eps}
  \caption{Exemplo de sistema de 3 elevadores com 8 andares, com um pedido para
    descer a partir do oitavo andar. A lotação dos elevadores está representada
    em percentual dentro deles, e seus programas são representados por setas.}
  \label{fig:elevadores-1}
\end{figure}

Utilizando o exemplo da Figura~\ref{fig:elevadores-1}, podemos calcular o custo
de cada elevador. Nela, temos 3 elevadores:

\begin{itemize}
\item \textbf{$E_{1}$}, no sétimo andar, com carga $20\%$ e um destino: o segundo andar;
\item \textbf{$E_{2}$}, no primeiro andar, com carga $10\%$ e um destino: o sexto andar;
\item \textbf{$E_{3}$}, no sétimo andar, com carga $90\%$ e um destino: o primeiro andar;
\end{itemize}

Sabemos que há um pedido no oitavo andar, e que ele quer descer\footnote{Na
  Figura~\ref{fig:elevadores-1}, representado pelo círculo com um \textbf{D}, de
\textit{Down}.}.

Para o Elevador $E_{1}$:

\[J(1) = g_{1}f_{1} = 0.2 \times 2 = 0.4\]

$g_{1}$ é $0.2$, pois sua lotação é $20\%$, e $f_{1}$ é $2$, pois o elevador
$E_{1}$ deve subir do sétimo para o oitavo andar e descer novamente até o sétimo.

Para o Elevador $E_{2}$:

\[J(2) = g_{2}f_{2} = 0.1 \times 8 = 0.8\]

$g_{2}$ é $0.1$, pois sua lotação é $10\%$\footnote{Como não temos informações a
respeito do futuro, não podemos considerar alterações na carga de um elevador.},
e $f_{2}$ é $8$, pois o elevador deverá subir oito andares.

Para o Elevador $E_{3}$:

\[J(3) = g_{3}f_{3} = 0.9 \times 2 = 1.8\]

$g_{3}$ é $0.9$, pois sua lotação é $90\%$, e $f_{3}$ é $2$, pois o elevador
$E_{3}$ deve subir do sétimo para o oitavo andar e descer novamente até o sétimo.

Vemos que, para esta função de custo, neste sistema, é vantajoso mudar o sentido
de $E_{1}$ para atender o chamado no oitavo andar.

Várias funções de custo podem ser experimentadas e comparadas.

Outras funções de custo levariam em consideração mudanças de direção de viagem
\footnote{\textit{e.g.}, pode ser vantajoso um elevador mudar de direção para atender um
pedido a um andar de distância, caso a alternativa seja fazer o pedido esperar
um deslocamendo de dezenas de andares de outro elevador.}, ou ainda tentar
manter todos os custos o mais baixo possível, ao mesmo tempo que sejam todos o
mais próximos uns dos outros.

Uma outra função de custo possível seria:

\[J(e) = \sqrt{g_{e}f_{e}^{2}}\]

Esta função penaliza mais o movimento, elevando ele ao quadrado.

Para o exemplo da Figura~\ref{fig:elevadores-1}, temos:

\[J(1) = \sqrt{g_{1}f_{1}^{2}} = \sqrt{0.2 \times 2^2} = \sqrt{0.8} = 0.8944\]
\[J(2) = \sqrt{g_{2}f_{2}^{2}} = \sqrt{0.1 \times 8^2} = \sqrt{6.4} = 2.5298\]
\[J(3) = \sqrt{g_{3}f_{3}^{2}} = \sqrt{0.9 \times 2^2} = \sqrt{3.6} = 1.8973\]

Novamente, para esta função, o Elevador $E_{1}$ é eleito para atender o pedido.

\section{Planning}

% TODO: essa explicação pode melhorar ainda

A idéia do algoritmo de planning é estender o de função de custo, calculando a
mesma para vários passos no futuro~-~como em um jogo de xadrez. Busca-se o
caminho cuja soma tem o menor custo.

Há duas alternativas para esta árvore de decisões: a decisão pode ser ``qual
elevador deve atender o próximo pedido'' (Figura~\ref{fig:planning}),
ou ``qual pedido deve ser atendido por qual elevador''. % TODO: Esta ilustração

O horizonte de cálculo deve ser selecionado, dado que é um fator limitante no
tamanho do cálculo do algoritmo.

Cada decisão diferente, para cada elevador, é um nodo novo na árvore. Ao
escolher-se uma das alternativas (\textit{i.e.} a que, ao final de $x$ eventos
no futuro tem o menor custo), avança-se um passo na simulação e executa-se o
algoritmo novamente.

Na Figura~\ref{fig:planning}, vemos um exemplo de planning sendo executado com
horizonte 3 e dois elevadores. Para cada passo do algoritmo, a decisão a ser
tomada é ``qual elevador deve atender o próximo pedido da fila?'', e, para isto,
calcula-se a função de custo. O resultado da função pode ser visto entre
parênteses em cada nodo da árvore da Figura~\ref{fig:planning}.

Ao encontrarmos o horizonte (no caso da Figura~\ref{fig:planning}, no nível 3 da
árvore), soma-se os custos até lá (na Figura~\ref{fig:planning}, os círculos
abaixo do nível mais baixo indicam a soma dos custos). O caminho que leva ao
menor custo é o que deve ser tomado. No exemplo da Figura~\ref{fig:planning}, o
elevador $E2$ atenderá o primeiro e o segundo chamados da fila, e então o
elevador $E1$ atenderá o terceiro chamado, como pode ser visto pelo caminho destacado.

\begin{figure}[htb!]
  \centering
  \includegraphics[scale=0.6]{img/planning.eps}
  \caption{Exemplo de planning com horizonte 3 e dois elevadores}
\label{fig:planning}
\end{figure}

\section{Planning Multi-Agente}

Este algoritmo é uma extensão do algoritmo de Planning, onde, em vez de termos
um processamento central que decide que um elevador deve atender o pedido, temos
todos os elevadores calculando por conta própria se vale a pena atender um
pedido ou não~-~sem conhecimento do estado dos demais.

A literatura neste tópico é bastante escassa ainda.