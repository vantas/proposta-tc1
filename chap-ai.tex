\chapter{\label{chap:ai}Algoritmos de Inteligência Artificial para Elevadores}

Neste capítulo vamos apresentar:

\begin{itemize}
\item Os detalhes dos algoritmos selecionados e justificar a suas escolhas perante o problema;
\item Introduzir o modelo de simulação do sistema~-~ou seja, a modelagem
prédio/andares/elevadores (e não a modelagem do simulador propriamente dito);
\item Detalhes de cada algoritmo e descrever como esperamos que seja o resultado de seu uso junto ao sistema.
\end{itemize}

A busca pela solução do problema de atribuir elevadores para atender chamadas
feitas pelos passageiros, minimizando alguma métrica, é apresentada pela
literatura pesquisada na forma de algoritmos com complexidades distintas. Tais
complexidades vão desde algoritmos triviais, que sequer podem ser classificados
como algoritmos de Inteligência Artificial mas são interessantes para fins de
comparações, até soluções mais complexas, onde são necessários menores níveis de
abstração~-~ou seja, mais dados sobre o sistema são necessários para se chegar
a uma solução.

Em um hipotético cenário ideal, ter-se-ia todos os dados de cada
passageiro~-~\textit{i.e.} cada pessoa que chegasse ao elevador informaria de
antemão para qual andar desejaria ir. No entanto, isto não é realista no
contexto dos sistemas de elevadoras instalados atualmente, onde cada pessoa
apenas informa se deseja subir ou descer antes de sequer entrar em um elevador
e, conforme explicado na \ref{chap:problem}, é muito difícil saber com precisão
quantas pessoas estão esperando no corredor de cada andar. Portanto, os
algoritmos aqui descritos tentam fazer inferências a respeito de dados que não
possuem, quando relevante\footnote{\textit{e.g.} Podemos estimar a lotação do
elevador com base no peso reportado pela balança interna do elevador, que já se
encontra nele por motivos de segurança.}, ou tentam tomar decisões ignorando os
dados que não estão disponíveis.

Neste estudo serão apresentadas duas abordagens para encontrar uma solução para
o problema referido: a \textit{minimização de uma função de custo} e
\textit{planning}.

\section{\label{sec:ai:minimize-cost-function}Minimização da Função de Custo}

A primeira abordagem apresentada é simples: define-se uma função de custo,
inerente a cada elevador, que descreve matematicamente quão vantajoso é atender
um chamado, comparado a não atendê-lo. A decisão de qual elevador é escolhido
para atender o chamado é feita com base única e exclusivamente em qual deles
terá o menor resultado da função de custo. Esta abordagem pode ser representada
matematicamente por:

\[chooseElevator(c, s) = \argmin{e \in s} costFunction(c, e)\]

Onde:
\begin{itemize}
\item \textbf{$c$} é a chamada de corredor originada por uma pessoa;
\item \textbf{$s$} é o conjunto de todos os elevadores do sistema;
\item \textbf{$e$} é uma variável local que representa cada elevador.
\end{itemize}

O algoritmo \ref{alg:base} ilustra um algoritmo com o comportamento desta
função.

\begin{algorithm}[htb]
\begin{center}
\begin{algorithmic}[1]
\Function{ChooseElevator}{$call, elevatorSet, costFunction$}
  \State $selectedElevator \leftarrow null$
  \State $minCost \leftarrow \infty$
  \For{\textbf{each} $elevator$ in $elevatorSet$}
    \State $cost \leftarrow \Call{CostFunction}{$call, elevatorSet$}$
    \If{$cost = 0$}
      \State \textbf{return} $elevator$
    \EndIf
    \If{$cost < minCost$}
      \State $selectedElevator \leftarrow elevator$
      \State $minCost \leftarrow cost$
    \EndIf
  \EndFor
  \State \textbf{return} $selectedElevator$
\EndFunction
\end{algorithmic}
\end{center}
\caption
   {\label{alg:base}Algoritmo Base}
\end{algorithm}

Os argumentos para este algoritmo são:

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries $costFunction$}]
  \item[$call$] Abstração de uma chamada;
  \item[$elevatorset$] Conjunto de todos os elevadores do prédio;
  \item[$costFunction$] Ponteiro para a função de cálculo de custo.
\end{description}

Seu funcionamento pode ser descrito como: dada uma chamada, para cada elevador
presente no conjunto calcula-se o retorno da função de custo e o algoritmo
retorna o elevador com a menor função de custo correspondente. Além disso, há
uma otimização (programação dinâmica): se algum elevador possuir custo zero, o
algoritmo retorna imediatamente, como resultado, este elevador - pois nenhum
outro elevador poderá ter um retorno da função de custo melhor do que zero.

\subsection{\label{sec:ai:nn}Função de Custo \textit{Nearest Neighbour}}

A função de custo \textit{Nearest Neighbour}, ou \textit{Vizinho Mais Próximo},
é a mais simples de todas e servirá como base para comparação e avaliação dos
demais algoritmos e funções. Seu funcionamento é trivial: na ocorrência de uma
chamada, a mesma será atendida pelo elevador que encontra-se mais próximo do
andar de origem, independente de quaisquer outras variáveis. Esta função pode
ser representada matematicamente por:

\[nearestNeighbor(c, e) = d\]

Onde:
\begin{itemize}
\item \textbf{$c$} é a chamada de corredor originada por uma pessoa;
\item \textbf{$e$} é o elevador em questão;
\item \textbf{$d$} é a distância absoluta entre o andar em que se
encontra o elevador $e$ e o andar que deu origem ao chamado $c$.
\end{itemize}

O algoritmo \ref{alg:nn} exibe uma representação em pseudo-código desta função:

\begin{algorithm}[htb]
\begin{center}
\begin{algorithmic}[1]
\Function{NearestNeighbour}{$call, elevatorSet$}
  \State \textbf{return} \Call{abs}{$elevator.currentFloor - call.sourceFloor$}
\EndFunction
\Statex
\Function{Abs}{value}
  \If{$value > 0$}
    \State \textbf{return} $value$
  \EndIf
  \State \textbf{return} $-1 * value$
\EndFunction
\end{algorithmic}
\end{center}
\caption
   {\label{alg:nn}Nearest Neighbor}
\end{algorithm}

Um dos muitos problemas deste algoritmo é que ele pode causar muitas mudanças de
direção de um elevador, o que acarreta num tempo de espera maior para os
passageiros dele. O único propósito deste algoritmo é servir de base de
comparação com outros algoritmos propostos, de modo a validarmos o simulador.
Espera-se que uma melhora clara de desempenho seja notado ao comparar-se este
com o próximo dos mais triviais, o \textit{Nearest Neighbour Melhorado}.

% TODO: Quem fala nele?

\subsection{\label{sec:ai:nnm}Função de Custo \textit{Nearest Neighbour
Melhorado}}

Uma melhoria que pode ser feita ao algoritmo de \textit{Nearest Neighbour}
é considerar o sentido em que o elevador está indo para atender o chamado. Isto
implica em considerar-se agora a informação de sentido dos pedidos. É importante
notar que ainda não se considera quantas pessoas fizeram um pedido para qual
sentido~-~apenas sabe-se que há pedidos no andar, e como destinos tem-se ``para
cima'', ``para baixo'' ou ambos.

\begin{algorithm}[htb]
\begin{center}
\begin{algorithmic}[1]
\Function{BetterNearestNeighbour}{$call, elevatorSet$}
  \State \textbf{return} $???????$
\EndFunction
\end{algorithmic}
\end{center}
\caption
   {\label{alg:nnm}Nearest Neighbor Melhorado}
\end{algorithm}

Este algoritmo resolve o problema de mudanças de direção que o algoritmo de
\textit{Nearest Neighbour} sofre.

No entanto, sua escolha para este trabalho também se dá para fim de comparação
com os outros e validação do simulador. Como seu comportamento é diferente do
caso mais trivial, mas ainda assim bastante simples, poderá ser visto com clareza
algum tipo de melhora no tempo de resposta do sistema simulado, bem como a validade do simulador.

\section{\label{sec:ai:lotacao}Função de Custo \textit{Lotação-Deslocamento}}

O primeiro algoritmo de IA a ser testado é simples: define-se uma
função de custo, inerente a cada elevador, que descreve matematicamente quão
vantajoso é atender um pedido, comparado a não atendê-lo. A decisão de qual
elevador é escolhido para atender o pedido é feita com base única e
exclusivamente em qual deles terá o menor valor da função de custo.

Um exemplo de função de custo é:

\[
  J(e) = g_{e}f_{e}
\]

Onde:
\begin{itemize}
\item \textbf{$g_{e}$} é a lotação do elevador
\item \textbf{$f_{e}$} é
  \begin{itemize}
    \item zero, caso o programa atual do elevador faça com que ele passe por
      aquele andar
    \item o número de andares entre onde o elevador está e o pedido, caso o
      elevador não tenha um programa (\textit{i.e.}, ele esteja ocioso) ou o
      elevador esteja indo na direção do pedido.
    \item duas vezes o número de andares entre onde o elevador está e o pedido,
      caso ele mude de direção para atender este pedido.\footnote{Multiplica-se
        a distância por dois pois é necessário ir até o andar do pedido e então
        voltar para o andar onde se estava anteriormente, para só então atender
        o pedido.}
  \end{itemize}
\end{itemize}

\begin{figure}[htb!]
  \centering
  \includegraphics[scale=0.6]{img/elevator_example1.eps}
  \caption{Exemplo de sistema de 3 elevadores com 8 andares, com um pedido para
    descer a partir do oitavo andar. A lotação dos elevadores está representada
    em percentual dentro deles, e seus programas são representados por setas.}
  \label{fig:elevadores-1}
\end{figure}

Utilizando o exemplo da Figura~\ref{fig:elevadores-1}, podemos calcular o custo
de cada elevador. Nela, temos 3 elevadores:

\begin{itemize}
\item \textbf{$E_{1}$}, no sétimo andar, com carga $20\%$ e um destino: o segundo andar;
\item \textbf{$E_{2}$}, no primeiro andar, com carga $10\%$ e um destino: o sexto andar;
\item \textbf{$E_{3}$}, no sétimo andar, com carga $90\%$ e um destino: o primeiro andar;
\end{itemize}

Sabemos que há um pedido no oitavo andar, e que ele quer descer\footnote{Na
  Figura~\ref{fig:elevadores-1}, representado pelo círculo com um \textbf{D}, de
\textit{Down}.}.

Para o Elevador $E_{1}$:

\[J(1) = g_{1}f_{1} = 0.2 \times 2 = 0.4\]

$g_{1}$ é $0.2$, pois sua lotação é $20\%$, e $f_{1}$ é $2$, pois o elevador
$E_{1}$ deve subir do sétimo para o oitavo andar e descer novamente até o sétimo.

Para o Elevador $E_{2}$:

\[J(2) = g_{2}f_{2} = 0.1 \times 8 = 0.8\]

$g_{2}$ é $0.1$, pois sua lotação é $10\%$\footnote{Como não temos informações a
respeito do futuro, não podemos considerar alterações na carga de um elevador.},
e $f_{2}$ é $8$, pois o elevador deverá subir oito andares.

Para o Elevador $E_{3}$:

\[J(3) = g_{3}f_{3} = 0.9 \times 2 = 1.8\]

$g_{3}$ é $0.9$, pois sua lotação é $90\%$, e $f_{3}$ é $2$, pois o elevador
$E_{3}$ deve subir do sétimo para o oitavo andar e descer novamente até o sétimo.

Vemos que, para esta função de custo, neste sistema, é vantajoso mudar o sentido
de $E_{1}$ para atender o chamado no oitavo andar.

Várias funções de custo podem ser experimentadas e comparadas.

Outras funções de custo levariam em consideração mudanças de direção de viagem
\footnote{\textit{e.g.}, pode ser vantajoso um elevador mudar de direção para atender um
pedido a um andar de distância, caso a alternativa seja fazer o pedido esperar
um deslocamendo de dezenas de andares de outro elevador.}, ou ainda tentar
manter todos os custos o mais baixo possível, ao mesmo tempo que sejam todos o
mais próximos uns dos outros.

\subsection{\label{sec:ai:lotacaoquadratica}Função de Custo
\textit{Lotação-Deslocamento Quadrático}}

Uma outra função de custo possível seria:

\[J(e) = \sqrt{g_{e}f_{e}^{2}}\]

Esta função penaliza mais o movimento, elevando ele ao quadrado.

Para o exemplo da Figura~\ref{fig:elevadores-1}, temos:

\[J(1) = \sqrt{g_{1}f_{1}^{2}} = \sqrt{0.2 \times 2^2} = \sqrt{0.8} = 0.8944\]
\[J(2) = \sqrt{g_{2}f_{2}^{2}} = \sqrt{0.1 \times 8^2} = \sqrt{6.4} = 2.5298\]
\[J(3) = \sqrt{g_{3}f_{3}^{2}} = \sqrt{0.9 \times 2^2} = \sqrt{3.6} = 1.8973\]

Novamente, para esta função, o Elevador $E_{1}$ é eleito para atender o pedido.

\section{Planning}

% TODO: essa explicação pode melhorar ainda

A idéia do algoritmo de planning é estender o de função de custo, calculando a
mesma para vários passos no futuro~-~como em um jogo de xadrez. Busca-se o
caminho cuja soma tem o menor custo.

Há duas alternativas para esta árvore de decisões: a decisão pode ser ``qual
elevador deve atender o próximo pedido'' (Figura~\ref{fig:planning}),
ou ``qual pedido deve ser atendido por qual elevador''. % TODO: Esta ilustração

O horizonte de cálculo deve ser selecionado, dado que é um fator limitante no
tamanho do cálculo do algoritmo.

Cada decisão diferente, para cada elevador, é um nodo novo na árvore. Ao
escolher-se uma das alternativas (\textit{i.e.} a que, ao final de $x$ eventos
no futuro tem o menor custo), avança-se um passo na simulação e executa-se o
algoritmo novamente.

Na Figura~\ref{fig:planning}, vemos um exemplo de planning sendo executado com
horizonte 3 e dois elevadores. Para cada passo do algoritmo, a decisão a ser
tomada é ``qual elevador deve atender o próximo pedido da fila?'', e, para isto,
calcula-se a função de custo. O resultado da função pode ser visto entre
parênteses em cada nodo da árvore da Figura~\ref{fig:planning}.

Ao encontrarmos o horizonte (no caso da Figura~\ref{fig:planning}, no nível 3 da
árvore), soma-se os custos até lá (na Figura~\ref{fig:planning}, os círculos
abaixo do nível mais baixo indicam a soma dos custos). O caminho que leva ao
menor custo é o que deve ser tomado. No exemplo da Figura~\ref{fig:planning}, o
elevador $E2$ atenderá o primeiro e o segundo chamados da fila, e então o
elevador $E1$ atenderá o terceiro chamado, como pode ser visto pelo caminho destacado.

\begin{figure}[htb!]
  \centering
  \includegraphics[scale=0.6]{img/planning.eps}
  \caption{Exemplo de planning com horizonte 3 e dois elevadores}
\label{fig:planning}
\end{figure}

\section{Planning Multi-Agente}

Este algoritmo é uma extensão do algoritmo de Planning, onde, em vez de termos
um processamento central que decide que um elevador deve atender o pedido, temos
todos os elevadores calculando por conta própria se vale a pena atender um
pedido ou não~-~sem conhecimento do estado dos demais.

A literatura neste tópico é bastante escassa ainda.